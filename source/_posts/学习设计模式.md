---
title: 学习设计模式
date: 2016-06-08 21:20:49
tags: 
  - JavaScript
  - 设计模式
---
<!--more-->

### 外观模式（Facade） ###
&#160; &#160; &#160; &#160;对接口的二次封装隐藏其复杂性，简化使用。但也会增加程序的复杂度。

###### 兼容方式，简化对事件的绑定。
```JavaScript
  // 兼容所有浏览器的addEvent方法
  function addEvent(dom, type, fn) {
    if (dom.addEventListener) {
      dom.addEventListener(type, fn, false);
    }
    else if (dom.attachEvent) {
      dom.attachEvent('on' + type, fn);
    }
    else {
      dom['on' + type] = fn;
    }
  }
```
###### 封装多个功能，简化底层操作。
```JavaScript
  // 小型代码库
  var A = {
    g: function (id) {
      return document.getElementById(id);
    },
    css: function (id, key, value) {
      this.g(id).style[key] = value;
    },
    attr: function (id, key, value) {
      this.g(id)[key] = value;
    }
  }
```

### 适配器模式（Adapter） ###
&#160; &#160; &#160; &#160;将一个类（对象）的接口（方法或属性）转化成另外一个接口。
###### 参数适配
&#160; &#160; &#160; &#160;传入对象的时候，有不知道参数是否完整，如果一些参数没有填写则使用默认参数。在许多插件配置都是这么做的。
```JavaScript
  function doSomeThing (obj) {
    var _adapter = {
      name: 'lsl',
      age: 21,
      color: 'red',
      sex: 'man'
    };
    for (var i in _adapter) {
      _adapter[i] = obj[i] || _adapter[i];
    }
  }
```
###### 数据转换
&#160; &#160; &#160; &#160; 适配两组结构不一致的数据。
``` JavaScript
  var city = {
    shenzhen: 11,
    chengdu: 23,
    beijin: 20
  };

  function adapter (obj) {
    var newObj = [];
    for (city in obj) {
      newObj.push({
        name: city,
        id: obj[city]
      });
    }
    return newObj;
  }
  adapter(city); //[{name: shenzhen, id: 11}, ···];
```

### 代理模式（proxy） ###
当客户不方便直接访问一个对象或者不满足需要的时候，提供以个替身对象来控制这个对象的访问

![id](http://7xv9xo.com1.z0.glb.clouddn.com/blog_proxy.png)

###### 预加载图片
&#160; &#160; &#160; &#160; 用户可以直接通过__myImg__设置图片，但如果网速过慢，在页面会显示空白。如果我们通过__proxyImg__代理,那么如果网速不佳，在图片未加载成功之前，会先显示默认图片，再加载完成之后显示原本图片。

```JavaScript
  var myImg = (function () {
    var imgNode = document.createElement('img');
    document.body.appendChild(imgNode);

    return {
      setSrc: function (src) {
        imgNode.src = src;
      };
    }
  });

  var proxyImg = (function () {
    var img = new Image();
    img.onload = function () {
      myImg.serSrc(this.src);
    };
    return {
      setSrc: function (src) {
        myImg.setSrc('默认图片');
        img.src = src;
      };
    }
  });
```
### 观察者模式（observer） ###
观察者模式（observer）又叫做发布订阅模式或消息机制，解决了主体对象与观察者之间功能耦合
##### 简单的发布订阅模式
```JavaScript
  var Event = (function () {
    var clientList = {},
      listen,
      trigger,
      remove;

    listen = function (key, fn) {
      if (!clientList[key]) {
        clientList[key] = [];
      }
      clientList[key].push(fn);
    };
    trigger = function () {
      var key = Array.prototype.shift.call(arguments);
      fns = clientList[key];
      if (!fns || fns.length === 0) {
        return false;
      }
      for (var i = 0,fn; fn = fns[i++]) {
        fn.apply(this, arguments);
      }
    }
  })();

  //订阅一条消息
  Event.listen('msg', function (data) {
    console.log(data); // {name: 'lsl'}
  });
  // 发布一条消息
  Event.trigger('msg', {
    name: 'lsl'
  });
```
> 所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”。一个程序的设计总是可以分为可变的部分和不可变的部分。当我们找出可变的部分，并且把这些部分封装起来那么剩下的就是不变和稳定的部分。这些不变和稳定的部分是非常容易复用的。
